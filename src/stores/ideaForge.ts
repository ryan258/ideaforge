// src/stores/ideaForge.ts
import { defineStore } from 'pinia'

export const useIdeaForgeStore = defineStore('ideaForge', {
  state: () => ({
    // Current step in the idea forge process
    currentStep: 'crucible' as
      | 'crucible'
      | 'mold'
      | 'forge'
      | 'anvil'
      | 'workshop'
      | 'finishingTouch',

    // The original idea input by the user or generated by AI
    originalIdea: '',

    // Selected personas for targeting
    selectedPersonas: [] as string[],

    // Chosen direction for idea development
    chosenDirection: '',

    // Available directions for the idea
    availableDirections: [] as string[],

    // Current iteration of the idea (evolves through the process)
    currentIteration: '',

    // Generated social media content ideas
    socialMediaIdeas: [] as string[],

    // User preferences
    userPreferences: {
      preferredAIModel: 'ollama' as 'ollama' | 'openai' | 'claude'
    },

    // Error state
    error: null as string | null,

    // Loading state
    isLoading: false
  }),

  getters: {
    // Get the current idea (either the original or the latest iteration)
    currentIdea: (state) => state.currentIteration || state.originalIdea,

    // Check if we can move to the next step
    canProceedToNextStep: (state) => {
      // Logic to determine if the user can proceed based on current state
      // This is a simplified example and should be expanded based on specific requirements
      switch (state.currentStep) {
        case 'crucible':
          return !!state.originalIdea
        case 'mold':
          return state.selectedPersonas.length > 0
        case 'forge':
          return !!state.chosenDirection
        case 'anvil':
          return !!state.currentIteration
        case 'workshop':
          return state.socialMediaIdeas.length > 0
        default:
          return true
      }
    }
  },

  actions: {
    // Set the current step in the process
    setCurrentStep(step: 'crucible' | 'mold' | 'forge' | 'anvil' | 'workshop' | 'finishingTouch') {
      this.currentStep = step
    },

    // Set the original idea
    setOriginalIdea(idea: string) {
      this.originalIdea = idea
    },

    // Add a selected persona
    addPersona(persona: string) {
      this.selectedPersonas.push(persona)
    },

    // Remove a selected persona
    removePersona(persona: string) {
      this.selectedPersonas = this.selectedPersonas.filter((p) => p !== persona)
    },

    // Set the chosen direction for the idea
    setChosenDirection(direction: string) {
      this.chosenDirection = direction
    },

    // Add a new available direction
    addAvailableDirection(direction: string) {
      this.availableDirections.push(direction)
    },

    // Update the current iteration of the idea
    updateCurrentIteration(iteration: string) {
      this.currentIteration = iteration
    },

    // Add a social media content idea
    addSocialMediaIdea(idea: string) {
      this.socialMediaIdeas.push(idea)
    },

    // Set user preference for AI model
    setPreferredAIModel(model: 'ollama' | 'openai' | 'claude') {
      this.userPreferences.preferredAIModel = model
    },

    // Set error state
    setError(error: string | null) {
      this.error = error
    },

    // Set loading state
    setLoading(isLoading: boolean) {
      this.isLoading = isLoading
    },

    // Reset the entire store (useful when starting a new idea process)
    resetStore() {
      this.$reset()
    },

    // Async action to generate an idea using AI
    async generateIdeaWithAI() {
      this.setLoading(true)
      this.setError(null)
      try {
        // This is where we'd call our AI service
        // For now, let's simulate an API call
        await new Promise((resolve) => setTimeout(resolve, 1000))
        this.setOriginalIdea('AI-generated idea placeholder')
      } catch (error) {
        this.setError('Failed to generate idea. Please try again.')
      } finally {
        this.setLoading(false)
      }
    },

    // Async action to generate a persona using AI
    async generatePersonaWithAI() {
      this.setLoading(true)
      this.setError(null)
      try {
        // Simulating an API call for now
        await new Promise((resolve) => setTimeout(resolve, 1000))
        this.addPersona(`AI-generated persona ${this.selectedPersonas.length + 1}`)
      } catch (error) {
        this.setError('Failed to generate persona. Please try again.')
      } finally {
        this.setLoading(false)
      }
    },

    // Async action to generate a direction using AI
    async generateDirectionWithAI() {
      this.setLoading(true)
      this.setError(null)
      try {
        // Simulating an API call for now
        await new Promise((resolve) => setTimeout(resolve, 1000))
        this.addAvailableDirection(`AI-generated direction ${this.availableDirections.length + 1}`)
      } catch (error) {
        this.setError('Failed to generate direction. Please try again.')
      } finally {
        this.setLoading(false)
      }
    }
  }
})